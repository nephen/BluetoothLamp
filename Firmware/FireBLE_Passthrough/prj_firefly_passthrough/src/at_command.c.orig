/**
 ****************************************************************************************
 *
 * @file at_command.c
 *
 * @brief 
 *
 * Copyright (C) Firefly 2015-2016
 *
 * $Rev: 1.0 $
 *
 ****************************************************************************************
 */
 
 /**
 ****************************************************************************************
 * @addtogroup  USR
 * @{
 ****************************************************************************************
 */
 
 /*
 * INCLUDE FILES
 ****************************************************************************************
 */
#include "at_command.h"
#include "app_env.h"
#include "uart.h"
#include "lib.h"
#include "sleep.h"
#include "nvds.h"
#include "pwm.h"
#include "i2c.h"

/*
 * MACRO DEFINITIONS
 ****************************************************************************************
 */
#define LED_ON_DUR_ADV_FAST        2
#define LED_OFF_DUR_ADV_FAST       (uint16_t)((GAP_ADV_FAST_INTV2*0.625)/10)
#define LED_ON_DUR_ADV_SLOW        2
#define LED_OFF_DUR_ADV_SLOW       (uint16_t)((GAP_ADV_SLOW_INTV*0.625)/10)
#define LED_ON_DUR_CON          0xffff
#define LED_OFF_DUR_CON                   0
#define LED_ON_DUR_IDLE                   0
#define LED_OFF_DUR_IDLE                  0xffff


/*
 * LOCAL VARIABLE DEFINITIONS
 ****************************************************************************************
 */


/*
 * GLOBAL VARIABLE DEFINITIONS
 ****************************************************************************************
 */
extern uint8_t baudrate;
uint8_t i2c_buff[4];
extern bool i2c_is_finish(void);


/*
****************************************************************************************
* @brief             set_baudrate
* @param[in]         pcCommandString            ÃüÁîºÍ²ÎÊý´æ·ÅµØÖ·
* @param[in]         pcWriteBuffer              Ð´Èë´ËÊý×éµÄÃüÁî½«±»·¢ËÍµ½´®¿Ú
* @param[in]         commpare_length            ÃüÁîËùÕ¼³¤¶È
* @return            None
* @description       ÉèÖÃÄ£¿é²¨ÌØÂÊ£¬¸ñÊ½£ºAT+BAUDx,xÈ¡ÖµÎª0~16¡AAT+BAUD£ ºÍAT+BAUD±íÊ¾²éÑ¯µ±Ç°²¨ÌØÂÊ
*										UART_1200     = 0,     //!< Set baud rate to 1200 when UART clock is 8MHz //
*    								UART_2400     = 1,     //!< Set baud rate to 2400 when UART clock is 8MHz //
*    								UART_4800     = 2,     //!< Set baud rate to 4800 when UART clock is 8MHz //
*    								UART_9600     = 3,     //!< Set baud rate to 9600 when UART clock is 8MHz //
*    								UART_14400    = 4,     //!< Set baud rate to 14400 when UART clock is 8MHz //
*    								UART_19200    = 5,     //!< Set baud rate to 19200 when UART clock is 8MHz //
*    								UART_28800    = 6,     //!< Set baud rate to 28800 when UART clock is 8MHz //
*    								UART_38400    = 7,     //!< Set baud rate to 38400 when UART clock is 8MHz //
*    								UART_57600    = 8,     //!< Set baud rate to 57600 when UART clock is 8MHz //
*    								UART_64000    = 9,     //!< Set baud rate to 64000 when UART clock is 8MHz //
*    								UART_76800    = 10,    //!< Set baud rate to 76800 when UART clock is 8MHz //
*    								UART_115200   = 11,    //!< Set baud rate to 115200 when UART clock is 8MHz //
*    								UART_128000   = 12,    //!< Set baud rate to 128000 when UART clock is 8MHz //
*    								UART_230400   = 13,    //!< Set baud rate to 230400 when UART clock is 8MHz //
*    								UART_345600   = 14,    //!< Set baud rate to 345600 when UART clock is 8MHz //
*    								UART_460800   = 15,    //!< Set baud rate to 460800 when UART clock is 8MHz //
*    								UART_500000   = 16,    //!< Set baud rate to 500000 when UART clock is 8MHz //
*****************************************************************************************/
int set_baudrate( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	const int8_t *pcom;
	uint32_t pxParameterStringLength;
	int len;
	
	//the baudrate inquire with the follow byte is "?" or "\0"
	if(pcCommandString[commpare_length+1] == '?' || pcCommandString[commpare_length+1] == '\0')
	{
		len = commpare_length+1;
		memcpy(pcWriteBuffer, pcCommandString, len);
		len += sprintf((char *)pcWriteBuffer + len,":%d\r\nOK\r\n",baudrate);	
	}
	//set baudrate  with the follow byte is "="
	else if(pcCommandString[commpare_length+1] == '=')
	{
		// get parameter and fill into *pcom
		pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 0, &pxParameterStringLength);
		if(pxParameterStringLength != 0)
		{
			baudrate = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
			if(baudrate > 16)
			{
				baudrate = 3;
			}		
			ke_timer_set(APP_COM_AT_BAUDRATE_CHANGE, TASK_APP, 1);	
			len = sprintf((char *)pcWriteBuffer,"OK\r\n");	
		}
		else
		{
			len = sprintf((char *)pcWriteBuffer,"ERR\r\n");
		}
	}
	else
	{
		len = sprintf((char *)pcWriteBuffer,"ERR\r\n");		
	}
	return len;
}

/*
****************************************************************************************
* @brief           	 get_version
* @param[in]         pcCommandString            ÃüÁîºÍ²ÎÊý´æ·ÅµØÖ·
* @param[in]         pcWriteBuffer              Ð´Èë´ËÊý×éµÄÃüÁî½«±»·¢ËÍµ½´®¿Ú
* @param[in]         commpare_length            ÃüÁîËùÕ¼³¤¶È
* @return            None
* @description       »ñÈ¡°æ±¾ºÅ£¬ÃüÁî¸ñÊ½£ºAT+VERSION OR AT+VERSION?
*****************************************************************************************/
int get_version( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	int len;
	len = commpare_length+1;
	memcpy(pcWriteBuffer, pcCommandString, len);
	len += sprintf((char *)pcWriteBuffer + len,":%s %s\r\nOK\r\n",SOFTWARE_VERSION,RELEASE_DATE);
	return len;
}

/*
****************************************************************************************
* @brief             get_name
* @param[in]         pcCommandString            ÃüÁîºÍ²ÎÊý´æ·ÅµØÖ·
* @param[in]         pcWriteBuffer              Ð´Èë´ËÊý×éµÄÃüÁî½«±»·¢ËÍµ½´®¿Ú
* @param[in]         commpare_length            ÃüÁîËùÕ¼³¤¶È
* @return            None
* @description       »ñÈ¡Éè±¸Ãû£¬ÃüÁî¸ñÊ½£ºAT+NAME OR AT+NAME?
*****************************************************************************************/
int get_name( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
		nvds_tag_len_t name_length = 31 - 5; 
		int len;
		len = commpare_length+1;
		memcpy(pcWriteBuffer, pcCommandString, len);
		pcWriteBuffer[len++] = ':';

    if (NVDS_OK != nvds_get(NVDS_TAG_DEVICE_NAME, &name_length, pcWriteBuffer+len))
    {
        // NVDS is empty, use default name
        name_length = strlen(QN_LOCAL_NAME);
        strcpy((char *)pcWriteBuffer+len, QN_LOCAL_NAME);			
    }
    else
    {
        name_length--; // Discard '\0'
    }
		len+=name_length;
		len+=sprintf((char *)pcWriteBuffer+len,"\r\nOK\r\n");
	return len;
}

/*
****************************************************************************************
* @brief             ble_discon
* @param[in]         pcCommandString            ÃüÁîºÍ²ÎÊý´æ·ÅµØÖ·
* @param[in]         pcWriteBuffer              Ð´Èë´ËÊý×éµÄÃüÁî½«±»·¢ËÍµ½´®¿Ú
* @param[in]         commpare_length            ÃüÁîËùÕ¼³¤¶È
* @return            None
* @description       ¶Ï¿ªµ±Ç°Á¬½Ó£¬ÃüÁî¸ñÊ½£ºAT+DISCON
*****************************************************************************************/
int ble_discon( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	app_gap_discon_req(0);
	return sprintf((char*)pcWriteBuffer,"OK\r\n");
}

/*
****************************************************************************************
* @brief             ble_adv
* @param[in]         pcCommandString            ÃüÁîºÍ²ÎÊý´æ·ÅµØÖ·
* @param[in]         pcWriteBuffer              Ð´Èë´ËÊý×éµÄÃüÁî½«±»·¢ËÍµ½´®¿Ú
* @param[in]         commpare_length            ÃüÁîËùÕ¼³¤¶È
* @return            None
* @description       ¿ªÆô»òÕß¹Ø±Õ¹ã²¥£¬ÃüÁî¸ñÊ½£ºAT+ADV=0  ¿ªÆô¹ã²¥    AT+ADV=1   ¹Ø±Õ¹ã²¥
*****************************************************************************************/
int ble_adv( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	const int8_t *pcom;
	int32_t arg1;
	uint32_t pxParameterStringLength;

	pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 1, 0, &pxParameterStringLength);
	arg1 = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
	if(arg1 == 0)
	{
		usr_led1_set(LED_ON_DUR_IDLE,LED_OFF_DUR_IDLE);
		app_gap_adv_stop_req();
	}
	else if(arg1 == 1)
	{
				usr_led1_set(LED_ON_DUR_ADV_FAST,LED_ON_DUR_ADV_FAST);
				app_gap_adv_start_req(GAP_GEN_DISCOVERABLE|GAP_UND_CONNECTABLE,
						app_env.adv_data, app_set_adv_data(GAP_GEN_DISCOVERABLE),
						app_env.scanrsp_data, app_set_scan_rsp_data(app_get_local_service_flag()),
						GAP_ADV_FAST_INTV1, GAP_ADV_FAST_INTV2);
				ke_timer_set(APP_ADV_INTV_UPDATE_TIMER,TASK_APP,30);
	}
	else
	{
		return sprintf((char*)pcWriteBuffer,"ERR\r\n");
	}
	return sprintf((char*)pcWriteBuffer,"OK\r\n");
}
void pwm_io_config(enum PWM_CH ch)
{
	if(ch == PWM_CH0)
	{
    syscon_SetPMCR1WithMask(QN_SYSCON,P27_MASK_PIN_CTRL, P27_PWM0_PIN_CTRL);//P2.7 pwm0
		gpio_pull_set(GPIO_P27, GPIO_PULL_UP);
	}
	else if(ch == PWM_CH1)
	{
		syscon_SetPMCR1WithMask(QN_SYSCON,P26_MASK_PIN_CTRL, P26_PWM1_PIN_CTRL);//P2.6 pwm1
		gpio_pull_set(GPIO_P26, GPIO_PULL_UP);
	}
}

/*
****************************************************************************************
* @brief             ble_pwm
* @param[in]         pcCommandString            ÃüÁîºÍ²ÎÊý´æ·ÅµØÖ·
* @param[in]         pcWriteBuffer              Ð´Èë´ËÊý×éµÄÃüÁî½«±»·¢ËÍµ½´®¿Ú
* @param[in]         commpare_length            ÃüÁîËùÕ¼³¤¶È
* @response          None
* @return
* @description       ÆôÓÃ»òÕß¹Ø±ÕPWM£¬ÃüÁî¸ñÊ½£ºAT_PWM=
*****************************************************************************************/
int ble_pwm( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	//È¡²ÎÓÃÖ¸ÕëºÍ³¤¶ÈÉùÃ÷
	const int8_t *pcom;
	uint32_t pxParameterStringLength;

	//PWM²ÎÊý
	enum PWM_CH ch;
	uint16_t pscal;
	uint16_t periodcount;
	uint16_t pulsecount;
	
  uint8_t parm_num = at_get_parameters_numbers((const uint8_t*)pcCommandString + commpare_length + 2);

	//Èç¹ûÃüÁîÖÐÐ¯´ø²ÎÊý
	if(pcCommandString[commpare_length+1] == '=')
	{
		//Èç¹ûÐ¯´ø4¸ö²ÎÊý,ÔòÒÀ´ÎÎªÍ¨µÀÑ¡Ôñ¡¢·ÖÆµÏµÊý¡¢ÖÜÆÚºÍÕ¼¿Õ±È
		if(parm_num == 4)
		{
			// pwm_ch?
			pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 0, &pxParameterStringLength);
			if(pxParameterStringLength == 1 )
			{ 
				if(pcom[0] == '0')
				{
					ch = PWM_CH0;
				}
				else if(pcom[0] == '1')
				{
					ch = PWM_CH1;
				}else
				{
					goto pram_err;
				}
			}
			else
			{
				goto pram_err;
			}	
			
			pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 1, &pxParameterStringLength);
			if(pxParameterStringLength > 0)
			{
				pscal = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
				if(pscal > 0x3FF)
				{
					goto pram_err;
				}
			}
			else
			{
				goto pram_err;
			}

			pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 2, &pxParameterStringLength);
			if(pxParameterStringLength > 0)
			{
				periodcount = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
				if(periodcount > 0xFF)
				{
					goto pram_err;
				}
			}
			else
			{
				goto pram_err;
			}			
			
			pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 3, &pxParameterStringLength);
			if(pxParameterStringLength > 0)
			{
				pulsecount = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
				if(pulsecount > 0xFF)
				{
					goto pram_err;
				}
			}
			else
			{
				goto pram_err;
			}

			//Parameters without error
			pwm_init(ch);
			pwm_io_config(ch);	
			pwm_config(ch, pscal, periodcount,pulsecount);
			pwm_enable(ch, MASK_ENABLE);			
	
		}
		//Èç¹ûÖ»ÓÐÒ»¸ö²ÎÊý£¬ÄÇ¾Í´ú±íÖ¸Ê¾¹Ø±ÕÄÄÒ»¸öÍ¨µÀ
		else if(parm_num == 1)
		{
			if(pcCommandString[commpare_length + 2] == '0')
			{
				pwm_enable(PWM_CH0, MASK_DISABLE);
			}
			else if((pcCommandString[commpare_length + 2] == '1'))
			{
				pwm_enable(PWM_CH1, MASK_DISABLE);
			}
			else
			{
				goto pram_err;
			}
		}
		else
		{
			goto pram_err;
		}
	}
	else
	{
		goto pram_err;
	}
	
	return sprintf((char*)pcWriteBuffer,"OK\r\n");
	
pram_err:	
	return sprintf((char*)pcWriteBuffer,"ERR\r\n");
}


int ble_i2c( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	const int8_t *pcom;
	uint32_t pxParameterStringLength;
	
	uint8_t len;
	uint8_t i2c_addr ;
	uint8_t i2c_reg  ;
	uint8_t i2c_data;

	if(pcCommandString[commpare_length+1] == '=')
	{
		//i2c_addr
		pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 1, &pxParameterStringLength);
		if(pxParameterStringLength > 0)
		{
			i2c_addr = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
		}
		else
		{
			goto pram_err;
		}
		
		//i2c_reg
		pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 2, &pxParameterStringLength);
		if(pxParameterStringLength > 0)
		{
			i2c_reg  = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 
		}
		else
		{
			goto pram_err;
		}
		
		// i2c R&W?
		pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 0, &pxParameterStringLength);
		if(pxParameterStringLength == 1)
		{ 
			syscon_SetPMCR1WithMask(QN_SYSCON,P23_MASK_PIN_CTRL | P24_MASK_PIN_CTRL,P23_I2C_SDA_PIN_CTRL | P24_I2C_SCL_PIN_CTRL);	
			i2c_init(I2C_SCL_RATIO(100000), i2c_buff, 4);
			if(pcom[0] == 'R')
			{
				i2c_data = I2C_BYTE_READ(i2c_addr,i2c_reg);
				if(i2c_is_finish())
				{
					len = commpare_length+1;
					memcpy(pcWriteBuffer, pcCommandString, len);
					len += sprintf((char *)pcWriteBuffer + len,":0x%02x\r\nOK\r\n",i2c_data);	
					return len;
				}
				goto pram_err; 
			}
			else if(pcom[0] == 'W')
			{
				//i2c_data
				pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 3, &pxParameterStringLength);
				if(pxParameterStringLength > 0)
				{
					i2c_data = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength); 	
				}
				else
				{
					goto pram_err;
				}

				I2C_BYTE_WRITE(i2c_addr, i2c_reg, i2c_data);
				if(!i2c_is_finish())
				{
					goto pram_err;
				}

			}
		}
		else
		{
			goto pram_err;
		}	
	}
	else
	{
		goto pram_err;
	}
	return sprintf((char*)pcWriteBuffer,"OK\r\n");
	
pram_err:	
	return sprintf((char*)pcWriteBuffer,"ERR\r\n");
}

int ble_gpio( const uint8_t * const pcCommandString,uint8_t* pcWriteBuffer,uint32_t commpare_length)
{
	const int8_t *pcom;
	uint32_t pxParameterStringLength;
	uint8_t len;
	
	enum gpio_pin pin;
	enum gpio_level level;
	uint8_t gpio_num;
	
	
	pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 0, &pxParameterStringLength);
	if(pxParameterStringLength > 0)
	{
		gpio_num = at_HEXstringToNum((const uint8_t *)pcom, pxParameterStringLength);
		switch(gpio_num)
		{
			case 0:
				pin = GPIO_P10;
				break;
			case 1:
				pin = GPIO_P11;
				break;
			case 2:
				pin = GPIO_P12;
				break;
			case 3:
				pin = GPIO_P13;
				break;
			case 4:
				pin = GPIO_P23;
				break;
			case 5:
				pin = GPIO_P24;
				break;
			case 6:
				pin = GPIO_P26;
				break;
			case 7:
				pin = GPIO_P27;
				break;
			default:
				goto pram_err;
//				break;
		}

		uint32_t x = pin;
    int n = 0;
    if (x == 0) n = 32;
    if ((x & 0x0000FFFF) == 0) { n += 16; x >>= 16; }
    if ((x & 0x000000FF) == 0) { n +=  8; x >>=  8; }
    if ((x & 0x0000000F) == 0) { n +=  4; x >>=  4; }
    if ((x & 0x00000003) == 0) { n +=  2; x >>=  2; }
    if ((x & 0x00000001) == 0) { n +=  1; }
			
    if (n < 16) 
    {
			syscon_SetPMCR0WithMask(QN_SYSCON,0x03 << n, 0 << n);
    }
    else 
    {
			syscon_SetPMCR1WithMask(QN_SYSCON,0x03 << (n-16), 0 << (n-16));
    }
	}
	else
	{
		goto pram_err;
	}
	if(pcCommandString[commpare_length+1] == '?' )
	{
		gpio_set_direction(pin, GPIO_INPUT);
		if(gpio_read_pin(pin) == GPIO_LOW)
		{
			gpio_num = 0;
		}
		else
		{
			gpio_num = 1;
		}
		len = commpare_length+1;
		memcpy(pcWriteBuffer, pcCommandString, len);
		len += sprintf((char *)pcWriteBuffer + len,":%d\r\nOK\r\n",gpio_num);	
		return len;
	}
	else if(pcCommandString[commpare_length+1] == '=')
	{
		pcom = at_get_parameter((const int8_t*)pcCommandString + commpare_length + 2, 1, &pxParameterStringLength);
		if(pxParameterStringLength == 1)
		{
			if(pcom[0] == '0')
			{
				level = GPIO_LOW;
			}
			else if (pcom[0] == '1')
			{
				level = GPIO_HIGH;
			}
			else
			{
				goto pram_err;
			}
			gpio_set_direction(pin, GPIO_OUTPUT);
			gpio_write_pin(pin, level);
		}	
		else
		{
			goto pram_err;		
		}

	}
	else
	{
		goto pram_err;
	}
	return sprintf((char*)pcWriteBuffer,"OK\r\n");	
	
pram_err:	
	return sprintf((char*)pcWriteBuffer,"ERR\r\n");
}
const At_CommandInput command[] =
{	
	{
		"BAUD",
		 set_baudrate
	},
	{
		"VERSION",
		 get_version
	},
	{
		"NAME",
		 get_name
	},
	{
		"DISCON",
		 ble_discon
	},	
	{
		"ADV",
		 ble_adv
	},
	{
		"PWM",
		 ble_pwm
	},
	{
		"I2C",
		 ble_i2c
	},
	{
		"GPIO",
		 ble_gpio
	}	
};


uint8_t at_command_length_get(const uint8_t *command)
{

	const uint8_t *sc;

	for (sc = command; (*sc != '\0') && (*sc != ' ') && (*sc != '?') && (*sc != '='); ++sc)
		/* nothing */;
	return sc - command;

}

/*
****************************************************************************************
* @brief             at_get_parameters_numbers
* @param[in]         pcCommandString
* @response          None
* @return            Ð¯´ø²ÎÊýµÄ¸öÊý
* @description       ¼ÆËãÃüÁîÖÐÐ¯´ø²ÎÊýµÄ¸öÊý
*****************************************************************************************/
uint8_t at_get_parameters_numbers( const uint8_t * pcCommandString )
{
	uint8_t cParameters = 0;
	const uint8_t * b_pcCommandString = pcCommandString;
	while( *pcCommandString != 0x00 )
	{
		if( ( *pcCommandString ) == ',' )
		{
				cParameters++;
		}
		pcCommandString++;
	}
	if(b_pcCommandString != pcCommandString)
		cParameters++;
	return cParameters;
}

/*
****************************************************************************************
* @brief              at_HEXstringToNum
* @param[in]          str				HEX string addr				
* @param[in]          length		HEX srring length						
* @response           None
* @return             result of conversion
* @description
*****************************************************************************************/
uint32_t at_HEXstringToNum(const uint8_t *str, uint32_t length)
{  
 uint8_t  revstr[16]={0}; 
 uint32_t   num[16]={0};  
 uint32_t   count=1;  
 uint32_t   result=0; 
 int 	i;
 memcpy(revstr,str,16);  
 for(i=length-1;i>=0;i--)  
 {  
	
	if ((revstr[i]>='0') && (revstr[i]<='9'))  
	   num[i]=revstr[i]-48;
	else if ((revstr[i]>='a') && (revstr[i]<='f'))  
	   num[i]=revstr[i]-'a'+10;  
	else if ((revstr[i]>='A') && (revstr[i]<='F'))  
	   num[i]=revstr[i]-'A'+10;  
	else  
	   num[i]=0;


	if('x' == revstr[1] || 'X' == revstr[1]) {

		result=result+num[i]*count;  
		count=count*16;

	 }
	 
	 else {
		 
		result=result+num[i]*count;  
		count=count*10;
	}
	
 }  
 	
 return result;  
}

/*
****************************************************************************************
* @brief           at_get_parameter
* @param[in]       pcCommandString    						´«Èë²ÎÊý×Ö·û´®Ö¸Õë
* @param[in]       uxWantedParameter  						Ô¤ÆÚ»ñÈ¡²ÎÊýÐòºÅ£¬´Ó0¿ªÊ¼£¬¶à¸ö²ÎÊýÒÔ","·Ö¸ô¿ª
* @param[in]       pxParameterStringLength    		µÚuxWantedParameter¸ö²ÎÊýµÄ³¤¶È
* @response        None
* @return          pcReturn												µÚuxWantedParameter¸ö²ÎÊýµÄÖ¸Õë
* @description     ¸Ãº¯Êý¹¦ÄÜÎª»ñÈ¡²ÎÊýÖÐµÚuxWantedParameter¸ö²ÎÊý
*****************************************************************************************/
const int8_t *at_get_parameter( const int8_t* pcCommandString, int32_t uxWantedParameter, uint32_t *pxParameterStringLength )
{
	//±êÊ¶»ñÈ¡µ½µÄ²ÎÊýÐòºÅ
	int uxParametersFound = 0;
	
	//ÓÃÓÚ¼ÆËã²ÎÊý³¤¶È
	const int8_t *pcReturn = pcCommandString;
	
  //³õÊ¼»¯²ÎÊý³¤¶È
	*pxParameterStringLength = 0;
	
	//»ñÈ¡µ½Ô¤ÆÚ²ÎÊýÐòºÅÎªÖ¹
	while(uxParametersFound <= uxWantedParameter)
	{
		if( *pcCommandString != 0x00 )
		{
			while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ',' ) )
			{
				pcCommandString++;
			}
			//Èç¹ûÊÇÔ¤ÆÚ»ñÈ¡µÄÐòºÅ²ÎÊý£¬¼ÆËã²ÎÊý³¤¶È£¬¶Ï¿ªÑ­»·
			if(uxParametersFound  ==  uxWantedParameter)
			{
				*pxParameterStringLength = pcCommandString - pcReturn;
				break;
			}
			//Èç¹ûÎ´µ½Ô¤ÆÚ²ÎÊýÐòºÅ£¬ÄÇÃ´½«pcReturn±£´æÎªÏÂÒ»¸ö²ÎÊýµÄÆðÊ¼Î»ÖÃ
			uxParametersFound++;
			if(( *pcCommandString ) != 0x00)
			{
				pcCommandString++;
				pcReturn = pcCommandString;
			}
		}
		else
		{
			break;
		}
	}
	
	return pcReturn;
}


/*
****************************************************************************************
* @brief
* @param[in]
* @response
* @return
* @description
*****************************************************************************************/
int at_process_command(const uint8_t* const pcCommandInput,uint8_t* pcWriteBuffer)
{
	uint8_t i;
	uint8_t s_input_length;
	uint8_t s_command_length;
	uint8_t s_commpare_length;
	const uint8_t *pcCommandString;
	int return_count = 0;
	
	// calculate the input length of at command,input at command start with "+"
	s_input_length   = at_command_length_get((const uint8_t *)pcCommandInput+1);
	
	// loop all pc_command
	for(i = 0;i < sizeof(command)/sizeof(At_CommandInput);i++)
	{
		//get the pc_command in turn
		pcCommandString  = command[i].pcCommand;
		
		//calculate the pc_command
		s_command_length = at_command_length_get((const uint8_t *)pcCommandString);

		//get the longest command length
		s_commpare_length = s_input_length > s_command_length?s_input_length:s_input_length;
		
		//compare nsize of the two command,if it's the same,jump to the relevant function 
		if (strncmp((const char *)pcCommandInput+1, (const char *)pcCommandString, s_commpare_length) == 0 ) 
		{
			return_count = command[i].pxCommandInterpreter(pcCommandInput,pcWriteBuffer,s_commpare_length);

			break;
		}		
	}
	// input_command not find in all pc_command
	if(i == sizeof(command)/sizeof(At_CommandInput))
	{
		return_count = sprintf((char *)pcWriteBuffer,"not find comamnd\r\n");
	}
	return return_count;
}



